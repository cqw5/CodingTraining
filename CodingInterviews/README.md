## Coding Interviews

| ID | Title | Solution  | Tag |
|:---:|:---|---|---|
|3|二维数组中的查找|[C++](./Solution/03/find.cpp)|数组|
|4|替换空格|[C++](./Solution/04/replaceSpace.cpp)|字符串|
|5|从尾到头打印链表|[C++](./Solution/05/printListFromTailToHead.cpp)|链表|
|6|重建二叉树|[C++](./Solution/06/reConstructBinaryTree.cpp)|树|
|7|用两个栈实现队列|[C++](./Solution/07/queueWithTwoStacks.cpp)|栈和队列|
|8|旋转数组的最小数字|[C++](./Solution/08/minNumberInRotateArray.cpp)| 查找|
|9|斐波那契数列|[C++](./Solution/09/Fibonacci.cpp)|递归和迭代|
|9.1|跳台阶|[C++](./Solution/09/jumpFloor.cpp)|递归和迭代|
|9.2|矩形覆盖|[C++](./Solution/09/rectCover.cpp)|递归和迭代|
|10|二进制中1的个数|[C++](./Solution/10/numberOf1.cpp)|位运算|
|11|数值的整数次方|[C++](./Solution/11/power.cpp)|代码的完整性|
|12|打印1到最大n的位数|[C++](./Solution/12/print1ToMaxOfDigits.cpp)|代码的完整性|
|13|在O(1)时间删除链表结点|[C++](./Solution/13/deleteNode.cpp)|代码的完整性|
|14|调整数组顺序使奇数位于偶数前面|[C++](./Solution/14/reOrderArray.cpp)|代码的完整性|
|15|链表中倒数第k个结点|[C++](./Solution/15/findKthToTail.cpp)|代码的鲁棒性|
|16|反转链表|[C++](./Solution/16/reverseList.cpp)|代码的鲁棒性|
|17|合并两个排序的链表|[C++](./Solution/17/mergeList.cpp)|代码的鲁棒性|
|18|树的子结构|[C++](./Solution/18/hasSubtree.cpp)|代码的鲁棒性|
|19|二叉树的镜像|[C++](./Solution/19/mirror.cpp)|面试思路|
|20|顺时针打印矩阵|[C++](./Solution/20/printMatrix.cpp)|画图让抽象形象化|
|21|包含min函数的栈|[C++](./Solution/21/stackWithMin.cpp)|举例让抽象具体化|
|22|栈的压入、弹出序列|[C++](./Solution/22/isPopOrder.cpp)|举例让抽象具体化|
|23|从上往下打印二叉树|[C++](./Solution/23/printFromTopToBottom.cpp)|举例让抽象具体化|
|24|二叉搜索树的后序遍历序列|[C++](./Solution/24/verifySquenceOfBST.cpp)|举例让抽象具体化|
|25|二叉树中和为某一值的路径|[C++](./Solution/25/findPath.cpp)|举例让抽象具体化|
|26|复杂链表的复制|[C++](./Solution/26/clone.cpp)|分解让复杂问题简单|
|27|二叉搜索树与双向链表|[C++](./Solution/27/convert.cpp)|分解让复杂问题简单|
|28|字符串的排列|[C++](./Solution/28/permutation.cpp)|分解让复杂问题简单|
|28.1|字符串的组合|[C++](./Solution/28/combination.cpp)|分解让复杂问题简单|
|28.2|八皇后问题|[C++](./Solution/28/queueChess.cpp)|分解让复杂问题简单|
|29|数组中出现次数超过一半的数字|[C++](./Solution/29/moreThanHalfNum.cpp)|时间效率|
|30|最小的K个数|[C++](./Solution/30/getLeastNumbers.cpp)|时间效率|
|31|连续子数组的最大和|[C++](./Solution/31/greatestSumOfSubarrays.cpp)|时间效率/动态规划|[](http://)
|32|整数中1出现的次数（从1到n整数中1出现的次数）|[C++](./Solution/32/numberOf1Between1AndN.cpp)|时间效率|
|33|把数组排成最小的数|[C++](./Solution/33/printMinNumber.cpp)|时间效率|
|34|丑数|[C++](./Solution/34/getUglyNumber.cpp)|时间空间效率的平衡|
|35|第一个只出现一次的字符位置|[C++](./Solution/35/firstNotRepeatingChar.cpp)|时间空间效率的平衡|
|36|数组中的逆序对|[C++](./Solution/36/inversePairs.cpp)|时间空间效率的平衡|
|37|两个链表的第一个公共结点|[C++](./Solution/37/findFirstCommonNode.cpp)|时间空间效率的平衡|
|38|数字在排序数组中出现的次数|[C++](./Solution/38/getNumberOfK.cpp)|知识迁移能力|
|39.1|二叉树的深度|[C++](./Solution/39/treeDepth.cpp)|知识迁移能力|
|39.2|平衡二叉树|[C++](./Solution/39/isBalanced.cpp)|知识迁移能力|
|40|数组中只出现一次的数字|[C++](./Solution/40/findNumsAppearOnce.cpp)|知识迁移能力|
|41.1|和为S的两个数字|[C++](./Solution/41/findNumbersWithSum.cpp)|知识迁移能力|
|41.2|和为S的连续正数序列|[C++](./Solution/41/findContinuousSequence.cpp)|知识迁移能力|
|42.1|翻转单词顺序列|[C++](./Solution/42/reverseSentence.cpp)|知识迁移能力|
|42.2|左旋转字符串|[C++](./Solution/42/leftRotateString.cpp)|知识迁移能力|
|43|n个骰子的点数|[C++](./Solution/43/diceProbiluty.cpp)|抽象建模能力|
|44|扑克牌顺子|[C++](./Solution/44/IsContinuous.cpp)|抽象建模能力|
|45|孩子们的游戏(圆圈中最后剩下的数)|[C++](./Solution/45/lastRemaining.cpp)|抽象建模能力|
|49|把字符串转换成整数|[C++](./Solution/49/StrToInt.cpp)|综合|
|51|数组中重复数字|[C++](./Solution/51/duplicate.cpp)|数组|
|52|构建乘积数组|[C++](./Solution/52/multiply.cpp)|数组|
|55|字符流中第一个不重复的字符|[C++](./Solution/55/firstAppearingOnce.cpp)|字符串|
|56|链表中环的入口结点|[C++](./Solution/56/entryNodeOfLoop.cpp)|链表|
|57|删除链表中重复的结点|[C++](./Solution/57/deleteDuplication.cpp)|链表|
|58|二叉树的下一个结点|[C++](./Solution/58/getNext.cpp)|树|
|59|对称的二叉树|[C++](./Solution/59/isSymmetrical.cpp)|树|
|60|把二叉树打印成多行|[C++](./Solution/60/print.cpp)|树|
|61|按之字形顺序打印二叉树|[C++](./Solution/61/print.cpp)|树|
|62|序列化二叉树|[C++](./Solution/62/treeSerAndDeSer.cpp)|树|


