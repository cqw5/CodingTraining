/*! Author: qwchen
 *! Date  : 2017-03-11
 *! 栈：18.14.1 下一个较大元素
 *! 题目描述：
 *    现在我们有一个int数组，请你找出数组中每个元素的下一个比它大的元素。
 *    给定一个int数组A及数组的大小n，请返回一个int数组，代表每个元素比他大的下一个元素,若不存在则为-1。保证数组中元素均为正整数。
 *  测试样例：[11,13,10,5,12,21,3],7
 *  返回：[13,21,12,12,21,-1,-1]
 */

/*
 * 思路：
 *   用一个栈：从栈顶到栈底是递增的，并且栈的最低部保存一个-1，该-1不出栈。
 *   从后向前遍历数组：
 *     - 如果当前元素>=栈顶元素，不断将栈顶元素出栈，直到栈顶大于当前元素或者栈顶==-1。
 *     （删除栈顶比当前元素小的元素，是因为比当前元素小，而且排在当前元素后面的元素，不可能成为数组前面元素的下一个大于它元素）
 *     - 将此时的栈顶元素作为当前元素的下一个大于它的元素，并将当前元素入栈。
 * 时间复杂度：O(n)。每个元素最多遍历一次，最多入栈一次，最多出栈一次。
 * 空间复杂度：O(n)。结果数组大小和栈大小。
 */
class NextElement {
public:
    vector<int> findNext(vector<int> A, int n) {
        vector<int> res(n, -1);
        stack<int> s;
        s.push(-1);
        s.push(A[n-1]);
        for (int i = n-2; i >= 0; i--) {
            while (s.top() != -1 && A[i] >= s.top()) {
                s.pop();
            }
            res[i] = s.top();
            s.push(A[i]);
        }
        return res;
    }
};

