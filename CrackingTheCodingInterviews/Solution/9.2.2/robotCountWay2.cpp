/*! Author: qwchen
 *! Date  : 2017-02-17
 *! 递归和动态规划: 9.2 机器人走方格II
 *! 题目描述
 *    有一个XxY的网格，一个机器人只能走格点且只能向右或向下走，要从左上角走到右下角。
 *    请设计一个算法，计算机器人有多少种走法。注意这次的网格中有些障碍点是不能走的。
 *    给定一个int[][] map(C++ 中为vector >),表示网格图，若map[i][j]为1则说明该点不是障碍点，否则则为障碍。
 *    另外给定int x,int y，表示网格的大小。请返回机器人从(0,0)走到(x - 1,y - 1)的走法数。
 */

/*
 * 思路：
 *   动态规划，利用原始的数组来存放中间状态
 *   先初始化第一行和第一列，若当前点的值为0，表示障碍物，则通过该点的路径为0；
 *                           否则，如果当前点的前一个点为0，那么当前点也就一样不可达，值置为0。
 *                                 否则，当前节点的值仍为1
 *   对于其他节点，该节点的值为该节点的左方节点的值+上方节点的值。
 * 时间复杂度：O(x * y)
 * 空间复杂度：O(x * y)
 */
class Robot {
public:
    int countWays(vector<vector<int> > map, int x, int y) {
        if (x <= 0 || y <= 0) return 0;
        for (int i = 1; i < y; i++) {
            if (map[0][i] != 0 && map[0][i - 1] == 0) {
                map[0][i] = 0;
            }
        }
        for (int i = 1; i < x; i++) {
            if (map[i][0] != 0 && map[i - 1][0] == 0) {
                map[i][0] = 0;
            }
        }
        for (int i = 1; i < x; i++) {
            for (int j = 1; j < y; j++) {
                if (map[i][j] != 0) {
                    map[i][j] = map[i][j - 1] + map[i - 1][j];
                }
            }
        }
        return map[x - 1][y - 1];
    }
};

