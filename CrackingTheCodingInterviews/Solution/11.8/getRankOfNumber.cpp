/*! Author: qwchen
 *! Date  : 2017-02-26
 *! 查找与排序：11.8 维护x的秩
 *! 题目描述：
 *    现在我们要读入一串数，同时要求在读入每个数的时候算出它的秩，即在当前数组中小于等于它的数的个数(不包括它自身)，
 *    请设计一个高效的数据结构和算法来实现这个功能。
 *    给定一个int数组A，同时给定它的大小n，请返回一个int数组，元素为每次加入的数的秩。保证数组大小小于等于5000。
 */

/*
 * 思路：
 *   对于每一个数，遍历其前面的数，看有多少个小于等于它
 * 时间复杂度：O(n^2)
 * 空间复杂度：O(n)
 */
class Rank {
public:
    vector<int> getRankOfNumber(vector<int> A, int n) {
        vector<int> res(n, 0);
        if (n <= 0) return res;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (A[j] <= A[i]) {
                    res[i]++;
                }
            }
        }
        return res;
    }
};

// 上面的解法效率是比较低的，对于每个元素到来时，从其前面查找小于等于它的元素的个数的时间复杂度是O(n)的
// 如果每个元素到来时，前面的元素都有已经排好序的，那从其前面查找小于等于它的元素的个数的时间复杂度就是O(logn)的（二分查找）
// 但是如果使用数组来存放其前面的元素，就要使用插入排序来完成这个数组的排序，而插入排序本身每一个插入操作的时间复杂度就是O(n)了
// 因此，只能使用二叉查找树来存放前面的元素，二叉查找树插入和查找的时间复杂度都是O(logn)
// 二叉查找树的结点是一个key,value对，key是元素，value是在序列中该key前小于等于该key的元素的个数
// 新来一个元素，要从其前面的元素中找到小于等于它的元素的个数时，只需要在二叉查找树中查找第一个key等于或小于它的结点
//   如果二叉查找树中存在key等于它的结点，返回该结点的count=value+1；然后将该结点的value+1
//   如果二叉查找树中不存在key等于它的结点，返回第一个小于它的结点的count=value+1；然后在树中插入该结点，value=count
//   如果二叉查找树中不存在key等于它的结点，也不存在小于它的结点，返回0；然后在树中插入该结点，value=0
// 时间复杂度可以降到O(nlogn)